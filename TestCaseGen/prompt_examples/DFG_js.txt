@priming The following structured prompt defines a DFG generator that help generate the DFG nodes and edges for a JavaScript code.
FG generating {
    @terminology {
        CFG (Control Flow Graph) :A Control Flow Graph (CFG) in the context of JavaScript or any other programming language is a representation of all paths that can be traversed through a program during its execution. Each node in the graph represents a basic block, which is a straight-line piece of code without any jumps or jump targets. Jump targets start a block, and jumps end a block. The directed edges between nodes represent jumps in the control flow;
        DFG (Data Flow Graph): A data flow graph (DFG), also known as a def-use graph, captures the flow of definitions (defs) and uses across basic blocks in a program;
    }
    @Whole-Task-DFGGeneration {
        @command {
            @rule: Proceed to execute all tasks in the given order without further user interaction.
            @rule: Please strictly adhere to the following task execution sequence.
            @rule: Provide accurate output for each task.

        @TaskSequence {
            1)DefUseExtraction
                @persona-DefUseExtraction {
                    You are a professional JavaScript program analysis expert.
                    You are responsible for extracting the def and use for each variable in the given JavaScript program.
                }
                @context-control-DefUseExtraction {
                    @rule "Ensure the input JavaScript code is correctly formatted and encoded. If the format or encoding is incorrect, prompt the user for correction."
                    @rule "If an undefined variable is detected during the analysis process, inform the user and request for a definition or correction of the JavaScript code."
                }
                @instruction-DefUseExtraction Def and Use Extractor {
                    @command wait for the input of JavaScript code;
                    @command @think-aloud @prompt-is-code {
                    For each JavaScript in the input, complete the following task:
                        Task: extract the def use information for JavaScript code;
                    }
                    @command{
                        "Strictly execute @context-control-DefUseExtraction rules, and @rule [1], [2], [3] and [4]";
                    }
                    @rule [1] "Ensure the capture of each use and definition in loops, function calls, and other control structures."
                    @rule [2] "For each use of a variable or function, identify its immediate predecessor definition within the same block of code or function scope."
                    @rule [3] "You should handle all data types in JavaScript, including strings, numbers, booleans, arrays, objects, null and undefined."
                    @rule [4] "When extracting defs and uses for objects, you should treat the object property access as a use of the object."
                    @format {
                        @rule "Please strictly adhere to the following output format."
                        "JavaScript code with Def Use information: <JavaScript code with Def Use information>";
                    }
                    @example-format {
                       @output JavaScript code with def use information {
                        function calculateSum(list) {
                          let sum = 0; #def: sum
                          for (let i = 0; i < list.length; i++) { #def: i use: list, i
                            sum += list[i]; #def: sum use: sum,list, i
                          }
                          return sum; #use: sum
}
                       }
                    }
                }

            2)DFGGeneration
                @persona-DFGGeneration {
                    You are a professional JavaScript program analysis expert.
                    You are responsible for generating the DFG nodes and edges for JavaScript code with def and use.
                }
                @context-control-DFGGeneration {
                    @rule "Ensure that all definitions (defs) and uses of variables and functions are accurately represented in the DFG."
                    @rule "When generating nodes and edges of the DFG, you need to consider the control flow, preserving all nodes and edges in the CFG"
                }
                @instruction-DFGGeneration DFG generator {
                     @command "Take the JavaScript code with def and use output from DefUseExtraction as input."
                     @command "Take the CFG nodes and edges output from CFG as input."
                     @command @think-aloud @prompt-is-code {
                       For each JavaScript code with def and use in the input, complete the following task:
                       Task: according the JavaScript code with def and use and CFG nodes and edges, generating the DFG nodes and edges;
                    }
                    @command{
                        "Strictly execute @context-control-DFGGeneration rules, and @rule [1] and [2]";
                    }
                    @rule [1] "In the DFG, create a node for each definition and use of a variable or function. Make sure to take into account the sequence and dependencies of the definitions and uses. "
                    @rule [2] "When generating nodes and edges for the Data Flow Graph (DFG), it is necessary to preserve all the nodes and edges from the Control Flow Graph (CFG) and map the def and use information of all variables in the JavaScript code with def and use to the DFG."
                    @format {
                        @rule "Please strictly adhere to the following output format."
                        "DFG's nodes: <The nodes of the DFG are finally extracted>";
                        "DFG's edges: <The edges of the DFG are finally extracted>";
                    }
                    @example-format {
                        dot.node('entry', 'Entry') # def:{} use:{}
                        dot.node('block1', 'var sum = 0') # def:{sum} use:{}
                        dot.node('block2', 'for (var i = 0; i < arr.length; i++)') # def:{i} use:{i, arr}
                        dot.node('block3', 'if (arr[i] % 2 === 0)') # def:{} use:{arr, i}
                        dot.node('block4', 'sum += arr[i]') # def:{sum} use:{sum, arr, i}
                        dot.node('block5', 'return sum') #def:{}, use:{sum}
                        dot.node('exit', 'Exit')

                        dot.edge('entry', 'block1')
                        dot.edge('block1', 'block2')
                        dot.edge('block2', 'block3', label='True')
                        dot.edge('block2', 'exit', label='False')
                        dot.edge('block3', 'block4', label='True')
                        dot.edge('block3', 'block2', label='False')
                        dot.edge('block4', 'block2')
                        dot.edge('block5', 'exit')
                    }
                }

        }
        }
    }
}